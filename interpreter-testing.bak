#lang racket
;; Run all tests by calling (test)

(require "interpreter.rkt")

;;;;**********TESTING**********

;; Performs a quick test to see if the test passed or failed and prints info about test if failure
(define pass?
  (lambda (actual expected)
    (if (equal? actual expected)
        (display 'Pass)
        (do-nothing (display "Fail {actual} ") (display actual)      ; displays info about the failed test
                   (display " != {expected} ") (display expected)))
    (newline)))

;; This function does nothing but allows for all the displays of a failed test to occure without an error
(define do-nothing ; there is probably a better way to do this but ̄\_(ツ)_/̄
  (lambda (a b c d)
    '())) ; literly does nothing (like what I wish I was doing)

;; Performs all the tests needed to prove the validity of the functions, I love this function
(define (test)

  ;Example:
  ; (diplay "Test #{test number} {test name}") (newline)
  ; (pass? {actual} {expected})
  ; (newline)

  ; checks the code is parsed into a tree as exprected
  (display "Test #1 parse-tree") (newline)                                            ;Test parse-tree
  (pass? (parse-tree "Tests/Test1.txt") '((var x) (= x 10) (var y (+ (* 3 x) 5))                ; 1/1
                                   (while (!= (% y x) 3) (= y (+ y 1)))
                                   (if (> x y) (return x)
                                       (if (> (* x x) y) (return (* x x))
                                           (if (> (* x (+ x x)) y)
                                               (return (* x (+ x x)))
                                               (return (- y 1)))))))
  (newline)

  ; checks math opperations perform correctly
  (display "Test #2 m-value") (newline)                                               ;Test m-value
  (pass? (m-value '(+ 3 (/ 4 2)) 's) 5)                                                         ; 1/2
  (pass? (m-value '(+ (* 3 2) (/ 4 (% 2 3))) 's) 8)                                             ; 2/2
  (newline)

  ; boolean ooporators for var assignments and conditions in if & while statements
  (display "Test #3 m-condition") (newline)                                           ;Test m-condition
  (pass? (m-condition '(== 1 1) 's) #t)                                                         ; 1/23
  (pass? (m-condition '(== 1 0) 's) #f)                                                         ; 2/23
  (pass? (m-condition '(!= 1 1) 's) #f)                                                         ; 3/23
  (pass? (m-condition '(!= 1 0) 's) #t)                                                         ; 4/23
  (pass? (m-condition '(> 1 1) 's) #f)                                                          ; 5/23
  (pass? (m-condition '(> 1 0) 's) #t)                                                          ; 6/23
  (pass? (m-condition '(> 0 1) 's) #f)                                                          ; 7/23
  (pass? (m-condition '(< 1 1) 's) #f)                                                          ; 8/23
  (pass? (m-condition '(< 1 0) 's) #f)                                                          ; 9/23
  (pass? (m-condition '(< 0 1) 's) #t)                                                          ; 10/23
  (pass? (m-condition '(>= 1 1) 's) #t)                                                         ; 11/23
  (pass? (m-condition '(>= 1 0) 's) #t)                                                         ; 12/23
  (pass? (m-condition '(>= 0 1) 's) #f)                                                         ; 13/23
  (pass? (m-condition '(<= 1 1) 's) #t)                                                         ; 14/23
  (pass? (m-condition '(<= 1 0) 's) #f)                                                         ; 15/23
  (pass? (m-condition '(<= 0 1) 's) #t)                                                         ; 16/23
  (pass? (m-condition '(&& #t #t) 's) #t)                                                       ; 17/23
  (pass? (m-condition '(&& #t #f) 's) #f)                                                       ; 18/23
  (pass? (m-condition '(|| #t #t) 's) #t)                                                       ; 19/23
  (pass? (m-condition '(|| #t #f) 's) #t)                                                       ; 20/23
  (pass? (m-condition '(|| #f #f) 's) #f)                                                       ; 21/23
  (pass? (m-condition '(! #t) 's) #f)                                                           ; 22/23
  (pass? (m-condition '(! #f) 's) #t)                                                           ; 23/23
  (newline)

  ; lookup variable's value in the state
  (display "Test #4 m-lookup") (newline)                                              ;Test m-lookup
  (pass? (m-lookup 'a '((a b c d)(2 5 6 7))) 2)                                                 ; 1/5
  (pass? (m-lookup 'c '((a b c d)(2 5 6 7))) 6)                                                 ; 2/5
  (pass? (m-lookup 'd '((a b c d)(2 5 6 7))) 7)                                                 ; 3/5
  ;(pass? (m-lookup 'd '()) "error) ;should error                                               ; 4/5
  ;(pass? (m-lookup 's '(()())) "error) ;should error                                           ; 5/5
  (newline)

  ; update variable's value in the state
  (display "Test #5 m-update") (newline)                                              ;Test m-update
  (pass? (m-update 's 3 '((a b c d)(2 5 6 7))) "error")                                         ; 1/6
  (pass? (m-update 'a 3 '((a b c d)(2 5 6 7))) '((a b c d)(3 5 6 7)))                           ; 2/6
  (pass? (m-update 'b 21 '((a b c d)(2 5 6 7))) '((a b c d)(2 21 6 7)))                         ; 3/6
  (pass? (m-update 'd 1 '((a b c d)(2 5 6 7)))  '((a b c d)(2 5 6 1)))                          ; 4/6
  (pass? (m-update 'a 0 '()) "error")                                                           ; 5/6
  (pass? (m-update 'a 0 '(()())) "error")                                                       ; 6/6
  (newline)

  ; add a variable to the state
  (display "Test #6 m-add") (newline)                                                 ;Test m-add
  (pass? (m-add 's '()) '((s)("init")))                                                         ; 1/4
  (pass? (m-add 's '(()())) '((s)("init")))                                                     ; 2/4
  (pass? (m-add 's '((a)(2))) '((s a)("init" 2)))                                               ; 3/4
  (pass? (m-add 's '((a b c)(3 4 5))) '((s a b c)("init" 3 4 5)))                               ; 4/4
  (newline)

  ; remove a variable from a state
  (display "Test #7 m-remove") (newline)                                              ;Test m-remove
  (pass? (m-remove 'a '((a b c d)(2 5 6 7))) '((b c d)(5 6 7)))                                 ; 1/6
  (pass? (m-remove 'b '((a b c d)(2 5 6 7))) '((a c d)(2 6 7)))                                 ; 2/6
  (pass? (m-remove 'd '((a b c d)(2 5 6 7))) '((a b c)(2 5 6)))                                 ; 3/6
  (pass? (m-remove 'a '((b c d)(5 6 7))) "error")                                               ; 4/6
  (pass? (m-remove 'a '(()())) "error")                                                         ; 5/6
  (pass? (m-remove 'a '()) "error")                                                             ; 6/6
  (newline)

  ; assign a variable
  (display "Test #8 m-assign") (newline)                                              ;Test m-assign
  ;(pass? (m-assign '(var 'a 2) '(()()) ;should error                                           ; 1/7
  (pass? (m-assign '(var a 2) '((a)(1))) '((a)(2)))                                             ; 2/7
  (pass? (m-assign '(var d 2) '((x y d z)(1 1 1 1))) '((x y d z)(1 1 2 1)))                     ; 3/7
  (pass? (m-assign '(var d 2) '((x y d z)(1 1 "init" 1))) '((x y d z)(1 1 2 1)))                ; 4/7
  (pass? (m-assign '(var d (+ 2 4)) '((x y d z)(1 1 1 1))) '((x y d z)(1 1 6 1)))               ; 5/7
  (pass? (m-assign '(var d (+ x 4)) '((x y d z)(2 3 7 1))) '((x y d z)(2 3 6 1)))               ; 6/7
  (pass? (m-assign '(var d (+ x (* y 2))) '((x y d z)(2 3 7 1))) '((x y d z)(2 3 8 1)))         ; 7/7
  (newline)

  ; declares a variable
  (display "Test #9 m-var-dec") (newline)                                             ;Test m-var-dec
  (pass? (m-var-dec '(var a) '((q)(1))) '((a q) ("init" 1)))                                    ; 1/9
  ;(pass? (m-var-dec '(var a) '((d a s)(1 2 3))) "error")             ;should error             ; 2/9
  (pass? (m-var-dec '(var a) '(()())) '((a)("init")))                                           ; 3/9
  ;(pass? (m-var-dec '(var a 1) '((d a s)(1 2 3))) "error")           ;should error             ; 4/9
  (pass? (m-var-dec '(var a 1) '((d s)(2 3))) '((a d s)(1 2 3)))                                ; 5/9
  (pass? (m-var-dec '(var a (+ x 1)) '((c s x)(2 3 4))) '((a c s x)(5 2 3 4)))                  ; 6/9
  (pass? (m-var-dec '(var a (+ x (* c 3))) '((c s x)(2 3 4))) '((a c s x)(10 2 3 4)))           ; 7/9
  ;(pass? (m-var-dec '(var a (+ x 1)) '((c s a x)(2 3 5 7))) "error") ;should error             ; 8/9
  ;(pass? (m-var-dec '(var a (+ a 1)) '((c s a x)(2 3 5 4))) "error") ;should error             ; 9/9
  (newline)

  ; tests interpreter functionality
  (display "Test #10 run") (newline)                                                  ;Test run
  (pass? (run "Tests/Test1.txt") 100)                                                           ; 1/27
  (pass? (run "Tests/Test2.txt") 21)                                                            ; 2/27
  (pass? (run "Tests/Test3.txt") 4)                                                             ; 3/27
  (pass? (run "Tests/Test4.txt") -10)                                                           ; 4/27
  (pass? (run "Tests/Test5.txt") 240)                                                           ; 5/27
  (pass? (run "Tests/Test6.txt") "true")                                                        ; 6/27
  (pass? (run "Tests/p1.Test1.txt") 150)                                                        ; 7/27
  (pass? (run "Tests/p1.Test2.txt") -4)                                                         ; 8/27
  (pass? (run "Tests/p1.Test3.txt") 10)                                                         ; 9/27
  (pass? (run "Tests/p1.Test4.txt") 16)                                                         ; 10/27
  (pass? (run "Tests/p1.Test5.txt") 220)                                                        ; 12/27
  (pass? (run "Tests/p1.Test6.txt") 5)                                                          ; 13/27
  (pass? (run "Tests/p1.Test7.txt") 6)                                                          ; 14/27
  (pass? (run "Tests/p1.Test8.txt") 10)                                                         ; 15/27
  (pass? (run "Tests/p1.Test9.txt") 5)                                                          ; 16/27
  (pass? (run "Tests/p1.Test10.txt") -39)                                                       ; 17/27

  ;The following tests are commented out beacuse they are supposed to throw errors,
  ;which halts the rest of the testing
  
  ;(pass? (run "Tests/p1.Test11.txt") "error" ) ;should error "use before declaring"            ; 18/27
  ;(pass? (run "Tests/p1.Test12.txt") "error")  ;should error "use before declaring"            ; 19/27
  ;(pass? (run "Tests/p1.Test13.txt") "error")  ;should error "use before assigning"            ; 20/27
  ;(pass? (run "Tests/p1.Test14.txt") "error")  ;should error "redefining"                      ; 21/27

  (pass? (run "Tests/p1.Test15.txt") "true")                                                    ; 22/27
  (pass? (run "Tests/p1.Test16.txt") 100)                                                       ; 23/27
  (pass? (run "Tests/p1.Test17.txt") "false")                                                   ; 24/27
  (pass? (run "Tests/p1.Test18.txt") "true")                                                    ; 25/27
  (pass? (run "Tests/p1.Test19.txt") 128)                                                       ; 26/27
  (pass? (run "Tests/p1.Test20.txt") 12)                                                        ; 27/27
  (newline)

  ) ;left hanging for easy test addition
